<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/embedded_ccpp/libs/highlight/github.min.css"> <link rel=stylesheet  href="/embedded_ccpp/css/franklin.css"> <link rel=stylesheet  href="/embedded_ccpp/css/poole_hyde.css"> <link rel=stylesheet  href="/embedded_ccpp/css/custom.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 968px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <link rel=icon  href="/embedded_ccpp/assets/c.svg"> <title>I Fundamentals - Operations</title> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <br> <img src="/embedded_ccpp/assets/KuwaitUniversityLogoTextLight.svg" style="width: 200px; height: auto; display: inline"> <h1 style="font-size:2em; opacity: 0.75;"><a href="/embedded_ccpp/">C/C++</a></h1> <p class=lead >Introduction to Embedded C/C++</p> </div> <script> function hidePart(part_div) { var x = document.getElementById(part_div); if (x.style.display === "none") { x.style.display = "block"; } else { x.style.display = "none"; } } </script> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/embedded_ccpp/">Home</a> <a class="sidebar-nav-item " href="https://alsaibie.github.io/me319">ME319 Mechatronics Course</a> <br> <small style="text-transform: uppercase; font-size: 0.75em">Lessons</small> <div class=part  onclick="hidePart('part1_div')">Fundamentals</div> <div id=part1_div  style="display:none;"> <a class="sidebar-nav-item " href="/embedded_ccpp/part_i/introduction/"><b>L0</b> <em>Introduction</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_i/lesson1/"><b>L1</b> <em>C and C++</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_i/lesson2/"><b>L2</b> <em>File and Program Structure</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_i/lesson3/"><b>L3</b> <em>Data Types</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_i/lesson4/"><b>L4</b> <em>Variables</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_i/lesson5/"><b>L5</b> <em>Arrays</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_i/lesson6/"><b>L6</b> <em>Type Qualifiers and Storage Specifiers</em></a> <a class="sidebar-nav-item active" href="/embedded_ccpp/part_i/lesson7/"><b>L7</b> <em>Operations</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_i/lesson8/"><b>L8</b> <em>Control Structures</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_i/lesson9/"><b>L9</b> <em>Functions</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_i/lesson10/"><b>L10</b> <em>Pointers and References</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_i/lesson11/"><b>L11</b> <em>Structs</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_i/lesson12/"><b>L12</b> <em>Classes</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_i/lesson13/"><b>L13</b> <em>Strings</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_i/lesson14/"><b>L14</b> <em>Preprocessor Directives</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_i/lesson15/"><b>L15</b> <em>Standard Library</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_i/lesson16/"><b>L16</b> <em>C/C++ Process Flow</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_i/lesson17/"><b>L17</b> <em>Debugging</em></a> </div> <div class=part  onclick="hidePart('part2_div')">Embedded Applications</div> <div id=part2_div  style="display:none;"> <a class="sidebar-nav-item " href="/embedded_ccpp/part_ii/lesson1/"><b>L1</b> <em>Event-Drive Programming</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_ii/lesson2/"><b>L2</b> <em>Threads</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_ii/lesson3/"><b>L3</b> <em>Interrupts</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_ii/lesson3/"><b>L4</b> <em>Scheduling</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_ii/lesson3/"><b>L5</b> <em>Real-Time Control</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_ii/lesson3/"><b>L6</b> <em>Filters and Digital Controllers</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_ii/lesson3/"><b>L7</b> <em>Object-Oriented Device Libraries</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_ii/lesson3/"><b>L8</b> <em>State-Machine</em></a> </div> <div class=part  onclick="hidePart('part3_div')">Code Optimization</div> <div id=part3_div  style="display:none;"> <a class="sidebar-nav-item " href="/embedded_ccpp/part_iii/lesson1/"><b>L1</b> <em>Variable Sizes</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_iii/lesson2/"><b>L2</b> <em>Probabilistic Priority</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_iii/lesson3/"><b>L3</b> <em>Jumps and Branches</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_iii/lesson4/"><b>L4</b> <em>Loop Jamming</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_iii/lesson4/"><b>L5</b> <em>Integer vs. Floating Point Math</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_iii/lesson4/"><b>L6</b> <em>Pass by Reference</em></a> <a class="sidebar-nav-item " href="/embedded_ccpp/part_iii/lesson4/"><b>L7</b> <em>Reduce Expensive Math</em></a> </div> <!-- <div class=part  onclick="hidePart('part4_div')">Arduino API</div> <div id=part4_div  style="display:none;"> <a class="sidebar-nav-item {{ispage /part_iv/lesson1/}}active{{end}}" href="/embedded_ccpp/part_iv/lesson1/"><b>L1</b> <em>Overview</em></a> <a class="sidebar-nav-item {{ispage /part_iv/lesson2/}}active{{end}}" href="/embedded_ccpp/part_iv/lesson2/"><b>L2</b> <em>Program Structure</em></a> <a class="sidebar-nav-item {{ispage /part_iv/lesson3/}}active{{end}}" href="/embedded_ccpp/part_iv/lesson3/"><b>L3</b> <em>Blinky Example</em></a> <a class="sidebar-nav-item {{ispage /part_iv/lesson4/}}active{{end}}" href="/embedded_ccpp/part_iv/lesson4/"><b>L4</b> <em>Input Output Example</em></a> <a class="sidebar-nav-item {{ispage /part_iv/lesson5/}}active{{end}}" href="/embedded_ccpp/part_iv/lesson5/"><b>L5</b> <em>Arduino Library</em></a> <a class="sidebar-nav-item {{ispage /part_iv/lesson6/}}active{{end}}" href="/embedded_ccpp/part_iv/lesson6/"><b>L6</b> <em>Custom Library</em></a> </div> --> <!-- <small style="text-transform: uppercase; font-size: 0.75em">Tutorials</small> <div class=part  onclick="hidePart('vscode_setup_div')">VSCode Setup</div> <div id=vscode_setup_div  style="display:none;"> <a class="sidebar-nav-item {{ispage /vscode_setup/host/}}active{{end}}" href="/embedded_ccpp/vscode_setup/host/"> <em>Compile for Host</em></a> <a class="sidebar-nav-item {{ispage /vscode_setup/platformio/}}active{{end}}" href="/embedded_ccpp/vscode_setup/platformio/"> <em>Platform-IO</em></a> </div> --> </nav> <p>&copy; Ali AlSaibie, PhD.</p> </div> </div> <div class="content container"> <div class=franklin-content ><h1 id=arithmetic_operations ><a href="#arithmetic_operations" class=header-anchor >Arithmetic Operations</a></h1> <p> <center><iframe title=vimeo-player  src="https://player.vimeo.com/video/386922824" width=640  height=370  frameborder=0  allowfullscreen></iframe></center> <br> If you have taken any math class in your life this will not look foreign to you. The four basic math operations &#40;add, subtract, multiply and divide&#41; don’t require any additional library and headers in C/C&#43;&#43;. </p> <table><tr><th align=right >Operator<th align=right >Name<th align=center >Example<tr><td align=right >&#43;<td align=right >Addition<td align=center >c &#61; a &#43; b<tr><td align=right >&#43;&#61;<td align=right >Addition assignment &#40; x&#43;&#61;y equiv. to x &#61; x&#43;y&#41;<td align=center >c &#43;&#61; b<tr><td align=right >-<td align=right >Subtraction<td align=center >c &#61; b – a<tr><td align=right >-&#61;<td align=right >Subtraction assignment &#40; x-&#61;y equiv. to x&#61;x-y&#41;<td align=center >c -&#61; b<tr><td align=right >*<td align=right >Multiplication<td align=center >j &#61; count*4<tr><td align=right >*&#61;<td align=right >Multiplication assignment &#40; x<em>&#61;y equiv. to x&#61;x</em>y&#41;<td align=center >i *&#61; k<tr><td align=right >/<td align=right >Division<td align=center >f &#61; r / 13<tr><td align=right >/&#61;<td align=right >Division assignment &#40; x/&#61;y equiv. to x&#61;x/y&#41;<td align=center >f /&#61; 13<tr><td align=right >&#43;&#43;<td align=right >Increment by one &#40;&#43;&#43;j is equiv. to j &#43;&#61; 1&#41;<td align=center >i&#43;&#43;<tr><td align=right >--<td align=right >Decrement by one &#40;--j is equiv. to j -&#61; 1&#41;<td align=center >--i<tr><td align=right >&#37;<td align=right >Modulus Operator<td align=center >c &#61; 3 &#37; 2 &#40;ans: 1&#41;</table> <p>Moreover, in C/C&#43;&#43; there is what is called an operation assignment. For example, if you wanted to add the value y to the variable x, you can do x &#61; x &#43; y or you can do x&#43;&#61;y. The two are equivalent. This latter one is called an addition assignment. </p> <p>The same can be done for subtraction, division and multiplication.</p> <p>We also have increment and decrement operators which are a handy way to increase or decrease a variable by 1 integer value, respectively. </p> <h2 id=arithmetic_assignment ><a href="#arithmetic_assignment" class=header-anchor >Arithmetic Assignment</a></h2> <p>The following two codes are exactly equivalent. Their assembly codes are exactly the same in fact. First we declare an int, initialize it to 0. Then increment it by 10, decrement it by 4, divide it by 2 then multiply it by 5 and finally increment it by 1. The final value of a should be 16</p> <pre><code class="cpp hljs"><span class=hljs-function ><span class=hljs-keyword >int</span> <span class=hljs-title >main</span><span class=hljs-params >(<span class=hljs-keyword >int</span> argc, <span class=hljs-keyword >char</span>* argv[])</span> </span>{
    <span class=hljs-keyword >int</span> a = <span class=hljs-number >0</span>;
    a += <span class=hljs-number >10</span>;
    a -= <span class=hljs-number >4</span>;
    a /= <span class=hljs-number >2</span>;
    a *= <span class=hljs-number >5</span>;
    a++;
    <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>;
}</code></pre> <pre><code class="cpp hljs"><span class=hljs-function ><span class=hljs-keyword >int</span> <span class=hljs-title >main</span><span class=hljs-params >(<span class=hljs-keyword >int</span> argc, <span class=hljs-keyword >char</span>* argv[])</span> </span>{
    <span class=hljs-keyword >int</span> a = <span class=hljs-number >0</span>;
    a = a + <span class=hljs-number >10</span>;
    a = a - <span class=hljs-number >4</span>;
    a = a / <span class=hljs-number >2</span>;
    a = a * <span class=hljs-number >5</span>;
    a = a + <span class=hljs-number >1</span>;
    <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>;
}</code></pre> <h2 id=post_vs_pre_increment ><a href="#post_vs_pre_increment" class=header-anchor >Post vs. Pre Increment</a></h2> <p>With increment and decrement operators, there is a difference between pre-incrementing and post-incrementing. To pre-increment K we would write &#43;&#43;k and to post-increment k we would write k&#43;&#43;.</p> <pre><code class="cpp hljs"><span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;iostream&gt;</span></span>

<span class=hljs-function ><span class=hljs-keyword >int</span> <span class=hljs-title >main</span><span class=hljs-params >(<span class=hljs-keyword >int</span> argc, <span class=hljs-keyword >char</span>* argv[])</span> </span>{
    <span class=hljs-keyword >int</span> k = <span class=hljs-number >1</span>;
    std::cout&lt;&lt;<span class=hljs-string >&quot;k = &quot;</span>&lt;&lt; k++ &lt;&lt;std::endl;
    <span class=hljs-comment >/* The output would be: k = 1 */</span>
    <span class=hljs-keyword >return</span> <span class=hljs-number >1</span>;
}</code></pre> <pre><code class="cpp hljs"><span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;iostream&gt;</span></span>

<span class=hljs-function ><span class=hljs-keyword >int</span> <span class=hljs-title >main</span><span class=hljs-params >(<span class=hljs-keyword >int</span> argc, <span class=hljs-keyword >char</span>* argv[])</span> </span>{
    <span class=hljs-keyword >int</span> k = <span class=hljs-number >1</span>;
    std::cout&lt;&lt;<span class=hljs-string >&quot;k = &quot;</span>&lt;&lt; ++k &lt;&lt;std::endl;
    <span class=hljs-comment >/* The output would be: k = 2 */</span>
    <span class=hljs-keyword >return</span> <span class=hljs-number >1</span>;
}</code></pre> <p>So what’s the difference you ask. Well, when you pre-increment a variable, what you are requesting is that a variable is first incremented and then read and used in the algorithm. </p> <p>In the second example the variable k was initially 1, it was incremented first then used in the cout command, so the output would be 2. But with the first example, the variable k is first read, used in the cout command and <strong>then</strong> incremented. So the output of cout is 1.</p> <p>In other words, with <strong>pre-</strong>: operate on it then use it, and with <strong>post-</strong>: use it then operate on it.</p> <h1 id=bitwise_operations ><a href="#bitwise_operations" class=header-anchor >Bitwise Operations</a></h1> <center><iframe title=vimeo-player  src="https://player.vimeo.com/video/386922845" width=640  height=370  frameborder=0  allowfullscreen></iframe></center> <br> <h2 id=expressing_binary_and_hexadecimal_values ><a href="#expressing_binary_and_hexadecimal_values" class=header-anchor >Expressing Binary and Hexadecimal Values</a></h2> <p>Before we overview bitwise operations, let’s learn how to express binary and hex values in C/C&#43;&#43;. </p> <p>To express binary numbers we add the prefix <strong>0b</strong> and to denote hex numbers we add the prefix <strong>0x</strong>.</p> <p><pre><code class="cpp hljs"><span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;cstdint&gt;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;iostream&gt;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;bitset&gt;</span></span>

<span class=hljs-keyword >using</span> <span class=hljs-keyword >namespace</span> std; 

<span class=hljs-function ><span class=hljs-keyword >int</span> <span class=hljs-title >main</span><span class=hljs-params >(<span class=hljs-keyword >int</span> argc, <span class=hljs-keyword >char</span>* argv[])</span> </span>{ 
    <span class=hljs-keyword >int</span> b = <span class=hljs-number >0b10001100</span>; <span class=hljs-comment >/* Store a binary value in b*/</span>
    <span class=hljs-function >bitset&lt;8&gt; <span class=hljs-title >binary_var</span><span class=hljs-params >(b)</span></span>; <span class=hljs-comment >/* Convert format for display only */</span>
    <span class=hljs-keyword >int</span> hex_var  = <span class=hljs-number >0x8C</span>; <span class=hljs-comment >/* Store a hexadecimal value in hex_var */</span>
    cout &lt;&lt; <span class=hljs-string >&quot;binary = &quot;</span> &lt;&lt; binary_var &lt;&lt; endl; 
    cout &lt;&lt; <span class=hljs-string >&quot;hex = &quot;</span> &lt;&lt; hex &lt;&lt; hex_var &lt;&lt; endl; <span class=hljs-comment >/* use std::hex to format into hex*/</span>
    <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>; 
}</code></pre> Output: <pre><code class="plaintext hljs">binary = 10001100
hex = 8c
</code></pre></p> <p>It’s not often required to print out binary or hex values through cout. But if needed, for a binary display you can covert the format as shown here using the bitset template. But you need to bring in the &lt;bitset&gt; header file.</p> <pre><code class="cpp hljs"><span class=hljs-function >bitset&lt;8&gt; <span class=hljs-title >binary_var</span><span class=hljs-params >(b)</span></span>; <span class=hljs-comment >/* Convert format for display only */</span></code></pre>
<p>To print a value in hex format through cout, include the keyword hex double angle left angle brackets. Any variable can be printed in hex for this way. </p>
<pre><code class="cpp hljs">cout &lt;&lt; <span class=hljs-string >&quot;hex = &quot;</span> &lt;&lt; hex &lt;&lt; hex_var &lt;&lt; endl; <span class=hljs-comment >/* use std::hex to format into hex*/</span></code></pre>
<h2 id=bitwise_operators ><a href="#bitwise_operators" class=header-anchor >Bitwise Operators</a></h2>
<p>Remember that everything in memory is ultimately stored as 1&#39;s and 0&#39;s. A char or uint8_t variable requires 8-bits of memory &#40;8 1&#39;s or 0&#39;s&#41;.</p>
<p>We can operate on bits directly. Manipulating memory and variables on a bit level is essential in embedded programming. The following table summarizes the bitwise operations used. </p>
<table><tr><th align=left >Operator<th align=left >Name<th align=left >Description<tr><td align=left >&amp;<td align=left >Bitwise AND<td align=left >Performs AND operation on each   corresponding bit of two arguments and returns   result<tr><td align=left >|<td align=left >Bitwise   OR<td align=left >Performs OR operation on each corresponding bit of two arguments and returns   result<tr><td align=left >^<td align=left >Bitwise Exclusive OR<td align=left >Performs Exclusive OR operation on each corresponding bit of two arguments and returns   result<tr><td align=left >~<td align=left >Bitwise NOT<td align=left >Performs a NOT operation on all the   bits of an argument and returns the result<tr><td align=left >&lt;&lt;   or &gt;&gt;<td align=left >Right shift or Left shift<td align=left >Shift   bits of argument 1 right/left by argument 2 places</table>
<h2 id=logical_bitwise_operations ><a href="#logical_bitwise_operations" class=header-anchor >Logical Bitwise Operations</a></h2>
<p>Let’s look at how we can apply some of the bitwise operations. Here we define three variables. We directly assign binary numbers to <strong>a</strong> and <strong>b</strong>, and a hex number to <strong>c</strong> which has the this binary value. </p>
<p>The following four operations show how to perform an AND, an OR, a NOR and a NOT operation. </p>
<p>You can also perform bitwise assignment as well. Numbers can be expressed in binary, hex as well as decimal.</p>
<p><pre><code class="cpp hljs"><span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;cstdint&gt;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;iostream&gt;</span></span>

<span class=hljs-keyword >using</span> <span class=hljs-keyword >namespace</span> std; 

<span class=hljs-function ><span class=hljs-keyword >int</span> <span class=hljs-title >main</span><span class=hljs-params >(<span class=hljs-keyword >int</span> argc, <span class=hljs-keyword >char</span>* argv[])</span> </span>{ 

    <span class=hljs-keyword >uint8_t</span> a = <span class=hljs-number >0b00001000</span>;
    <span class=hljs-keyword >uint8_t</span> b = <span class=hljs-number >0b10001111</span>;
    <span class=hljs-keyword >uint8_t</span> c = <span class=hljs-number >0xF7</span>; <span class=hljs-comment >/* 11110111 */</span>

    <span class=hljs-keyword >uint8_t</span> r1 = a &amp; b; <span class=hljs-comment >/* AND operation, result: 00001000 */</span>
    <span class=hljs-keyword >uint8_t</span> r2 = a | c; <span class=hljs-comment >/* OR operation,  result: 11111111 */</span>
    <span class=hljs-keyword >uint8_t</span> r3 = a ^ b; <span class=hljs-comment >/* NOR operation, result: 10000111 */</span>
    <span class=hljs-keyword >uint8_t</span> r4 = ~c;    <span class=hljs-comment >/* NOT operation, result: 00001000 */</span>

    cout &lt;&lt; <span class=hljs-string >&quot;r1= &quot;</span> &lt;&lt; hex &lt;&lt; (<span class=hljs-keyword >int</span>)r1 &lt;&lt; <span class=hljs-string >&quot;\n&quot;</span> ;
    cout &lt;&lt; <span class=hljs-string >&quot;r2= &quot;</span> &lt;&lt; hex &lt;&lt; (<span class=hljs-keyword >int</span>)r2 &lt;&lt; <span class=hljs-string >&quot;\n&quot;</span> ;
    cout &lt;&lt; <span class=hljs-string >&quot;r3= &quot;</span> &lt;&lt; hex &lt;&lt; (<span class=hljs-keyword >int</span>)r3 &lt;&lt; <span class=hljs-string >&quot;\n&quot;</span> ;
    cout &lt;&lt; <span class=hljs-string >&quot;r4= &quot;</span> &lt;&lt; hex &lt;&lt; (<span class=hljs-keyword >int</span>)r4 &lt;&lt; <span class=hljs-string >&quot;\n&quot;</span> ;

    r1 |= b; <span class=hljs-comment >/* OR operation, result: 10001111 */</span>
    cout &lt;&lt; <span class=hljs-string >&quot;r1= &quot;</span> &lt;&lt; hex &lt;&lt; (<span class=hljs-keyword >int</span>)r1 &lt;&lt; <span class=hljs-string >&quot;\n&quot;</span> ;
    <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>; 
}</code></pre> Output &#40;hex format&#41;: <pre><code class="plaintext hljs">r1= 8
r2= ff
r3= 87
r4= 8
r1= 8f
</code></pre></p>
<h3 id=and ><a href="#and" class=header-anchor >AND </a></h3>
<p>On a bit level an AND operation is similar to multiplication. If one is zero, the results is zero. </p>
<pre><code class="cpp hljs"><span class=hljs-keyword >uint8_t</span> r1 = a &amp; b; <span class=hljs-comment >/* AND operation, result: 00001000 */</span></code></pre>
<h3 id=or ><a href="#or" class=header-anchor >OR</a></h3>
<p>With OR, if at least one is 1 the result is 1</p>
<pre><code class="cpp hljs"><span class=hljs-keyword >uint8_t</span> r2 = a | c; <span class=hljs-comment >/* OR operation,  result: 11111111 */</span></code></pre>
<h3 id=nor ><a href="#nor" class=header-anchor >NOR</a></h3>
<p>With a NOR operation, if <strong>only one</strong> is equal to 1, the result is 1.</p>
<pre><code class="cpp hljs"><span class=hljs-keyword >uint8_t</span> r3 = a ^ b; <span class=hljs-comment >/* NOR operation, result: 10000111 */</span></code></pre>
<h3 id=not ><a href="#not" class=header-anchor >NOT</a></h3>
<p>A NOT operation just toggles the value. </p>
<pre><code class="cpp hljs"><span class=hljs-keyword >uint8_t</span> r4 = ~c;    <span class=hljs-comment >/* NOT operation, result: 00001000 */</span></code></pre>
<h2 id=bit-shifting ><a href="#bit-shifting" class=header-anchor >Bit-shifting</a></h2>
<p>It is often convenient to shift values at the bit level, especially when working with embedded systems. </p>
<p>Shifting, as the name implies, means moving the bits either to the left or the right, by a specified amount. To perform the shift, we use the double angled brackets followed by the number of shifts. </p>
<p><pre><code class="cpp hljs"><span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;cstdint&gt;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;iostream&gt;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;bitset&gt;</span></span>
<span class=hljs-keyword >using</span> <span class=hljs-keyword >namespace</span> std; 

<span class=hljs-function ><span class=hljs-keyword >int</span> <span class=hljs-title >main</span><span class=hljs-params >(<span class=hljs-keyword >int</span> argc, <span class=hljs-keyword >char</span>* argv[])</span> </span>{ 

    <span class=hljs-keyword >uint8_t</span> a = <span class=hljs-number >0b00000100</span>;
    <span class=hljs-keyword >uint8_t</span> b = <span class=hljs-number >0b10001111</span>;
    <span class=hljs-keyword >uint8_t</span> c = <span class=hljs-number >0xF7</span>; <span class=hljs-comment >/* 11110111 */</span>

    <span class=hljs-keyword >uint8_t</span> r1 = a &gt;&gt; <span class=hljs-number >2</span>; <span class=hljs-comment >/* Shift operation, result: 00000001 */</span>
    <span class=hljs-keyword >uint8_t</span> r2 = b &lt;&lt; <span class=hljs-number >4</span>; <span class=hljs-comment >/* Shift operation, result: 11110000 */</span>
    <span class=hljs-keyword >uint8_t</span> r3 = (a&lt;&lt;<span class=hljs-number >1</span>) | c; <span class=hljs-comment >/* Shift + OR NOR operation, result: 11111111 */</span>
    
    <span class=hljs-function >bitset&lt;8&gt; <span class=hljs-title >bin</span><span class=hljs-params >(r3)</span></span>;
    cout &lt;&lt; hex &lt;&lt; bin &lt;&lt; endl;
    <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>; 
}</code></pre> Output: <pre><code class="plaintext hljs">11111111
</code></pre></p>
<p>Bit shifting requires little effort by the CPU, it is actually also useful as a faster arithmetic technique. A right shift can be used to divide by powers of 2 rounded down. But users of this technique for arithmetic operations need to be wary of overflow and loss of precision. </p>
<h3 id=shifting_right ><a href="#shifting_right" class=header-anchor >Shifting right</a></h3>
<p>When shifting to the right, the rightmost bits fall into a black hole and disappear, the new ones to the left are zero &#40;no circulation&#41;</p>
<pre><code class="cpp hljs"><span class=hljs-keyword >uint8_t</span> r1 = a &gt;&gt; <span class=hljs-number >2</span>; <span class=hljs-comment >/* Shift operation, 2 places, result: 00000001 */</span></code></pre>
<h3 id=shifting_left ><a href="#shifting_left" class=header-anchor >Shifting left</a></h3>
<p>Similary, when shifting to the left, the leftmost bits fall into a giant pit and disappear, the new ones to the right are zero. </p>
<pre><code class="cpp hljs"><span class=hljs-keyword >uint8_t</span> r2 = b &lt;&lt; <span class=hljs-number >4</span>; <span class=hljs-comment >/* Shift operation, 4 places, result: 11110000 */</span></code></pre>
<h3 id=bit_numbering ><a href="#bit_numbering" class=header-anchor >Bit numbering</a></h3>
<p>In an 8-bit memory, the first bit to the left is denoted as bit 0 and the last one to the left as bit 7. With Little Endian convention, the lowest bit address &#40;bit 0&#41; is called the Least Significant Bit &#40;LSB&#41; and the bit with the highest address &#40;bit 7 here&#41; is called Most Significant Bit &#40;MSB&#41;</p>
<h1 id=logical_operations ><a href="#logical_operations" class=header-anchor >Logical Operations</a></h1>
<p>
<center><iframe title=vimeo-player  src="https://player.vimeo.com/video/386922865" width=640  height=370  frameborder=0  allowfullscreen></iframe></center>
<br>
 Logical expressions refer to <em>expressions</em> that can either be <strong>true</strong> or <strong>false</strong>. In C&#43;&#43; there is a <strong>bool</strong> data type, which can take only <strong>true</strong> or <strong>false</strong> as a value. The <strong>bool</strong> type is not built-in the C language, but can be easily defined manually as is often done. However, it is safer to have the bool type built-in. </p>
<p>Numerically, a zero is treated as false and a <strong>non-zero</strong> &#40;not just 1&#41; value is treated as true. Performing logical operations on logical expressions is done via the following operators. </p>
<table><tr><th align=left >Operator<th align=left >Name<th align=left >Description<tr><td align=left >&amp;&amp;<td align=left >Logical AND<td align=left >Returns 1 if inputs are all nonzero, 0 otherwise<tr><td align=left >||<td align=left >Logical OR<td align=left >Returns   0 if all inputs are zero, 1 otherwise<tr><td align=left >&#33;<td align=left >Logical NOT<td align=left >Return the opposite of the logical   value<tr><td align=left >&lt;,   &gt;, &#61;&#61;<td align=left >Greater   than, less than, logical equal<td align=left >Returns 1 if argument one is &#40;gt, lt, equal to&#41; argument two, 0 otherwise</table>
<p>Note that here we use a double ampersand for a logical AND, while we use a single ampersand for a bitwise AND operation. </p>
<p>Comparisons can also be done for numerical values. </p>
<p>Here are a few examples of how logical operations are used. <pre><code class="cpp hljs"><span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;cstdint&gt;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;iostream&gt;</span></span>

<span class=hljs-keyword >using</span> <span class=hljs-keyword >namespace</span> std; 
<span class=hljs-function ><span class=hljs-keyword >int</span> <span class=hljs-title >main</span><span class=hljs-params >(<span class=hljs-keyword >int</span> argc, <span class=hljs-keyword >char</span>* argv[])</span> </span>{ 
    <span class=hljs-keyword >uint8_t</span> a = <span class=hljs-number >3</span>; <span class=hljs-keyword >uint8_t</span> b = <span class=hljs-number >4</span>; <span class=hljs-keyword >float</span> c = <span class=hljs-number >3.0</span>; <span class=hljs-keyword >float</span> d = <span class=hljs-number >3.001</span>; 

    <span class=hljs-keyword >bool</span> r1 = (a == <span class=hljs-number >3</span>) &amp;&amp; (b == <span class=hljs-number >3</span>); <span class=hljs-comment >/* Logical Operation, result: 0 (false), as b = 4 */</span>
    <span class=hljs-keyword >bool</span> r2 = (a == <span class=hljs-number >3</span>) || (b == <span class=hljs-number >3</span>); <span class=hljs-comment >/* Logical Operation, result: 1 (true), as a = 3 */</span>
    <span class=hljs-keyword >bool</span> r3 = a == c; <span class=hljs-comment >/* Logical Operation, result: 1 (true), as 3 = 3.0 */</span>
    <span class=hljs-keyword >bool</span> r4 = a == d; <span class=hljs-comment >/* Logical Operation, result: 0 (false), as 3 &lt; 3.001 */</span>
    <span class=hljs-keyword >bool</span> r5 = a == (<span class=hljs-keyword >uint8_t</span>)d; <span class=hljs-comment >/* Logical Operation, result: 1 (true), as 3 = 3 */</span>
    <span class=hljs-keyword >bool</span> r6 = a &gt;= b; <span class=hljs-comment >/* Logical Operation, result: 0 (false) */</span>
    <span class=hljs-keyword >bool</span> r7 = !(a &gt;= b); <span class=hljs-comment >/* Logical Operation, result: 1 (true) */</span>
    <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>; 
}</code></pre></p>
<p>Here we compare if a equals 3, which is true, and compare if b equals 3 which is false and then we perform an AND operation between the two, which results in false. </p>
<pre><code class="cpp hljs"><span class=hljs-keyword >bool</span> r1 = (a == <span class=hljs-number >3</span>) &amp;&amp; (b == <span class=hljs-number >3</span>); <span class=hljs-comment >/* Logical Operation, result: 0 (false), as b = 4 */</span></code></pre>
<p>And here we do the same comparisons for a and b but then we perform an OR operation. This time the results is true is at least one of the expressions is true. Not that the logic here is different than with bitwise operations. An AND between multiple expressions is true only when all expressions are true. An OR between multiple expressions is true if at least one of the expressions is true. </p>
<pre><code class="cpp hljs"><span class=hljs-keyword >bool</span> r2 = (a == <span class=hljs-number >3</span>) || (b == <span class=hljs-number >3</span>); <span class=hljs-comment >/* Logical Operation, result: 1 (true), as a = 3 */</span></code></pre>
<p>We can compare values directly here and the results is true since <strong>a</strong> equals <strong>c</strong></p>
<pre><code class="cpp hljs"><span class=hljs-keyword >bool</span> r3 = a == c; <span class=hljs-comment >/* Logical Operation, result: 1 (true), as 3 = 3.0 */</span></code></pre>
<p>But <strong>a</strong> is not equal to <strong>d</strong> so that’s false.</p>
<pre><code class="cpp hljs"><span class=hljs-keyword >bool</span> r4 = a == d; <span class=hljs-comment >/* Logical Operation, result: 0 (false), as 3 &lt; 3.001 */</span></code></pre>
<p>If we convert <strong>d</strong> to an int we drop the decimal and it becomes equal to <strong>a</strong></p>
<pre><code class="cpp hljs"><span class=hljs-keyword >bool</span> r5 = a == (<span class=hljs-keyword >uint8_t</span>)d; <span class=hljs-comment >/* Logical Operation, result: 1 (true), as 3 = 3 */</span></code></pre>
<p><strong>a</strong> is smaller than <strong>b</strong> </p>
<pre><code class="cpp hljs"><span class=hljs-keyword >bool</span> r6 = a &gt;= b; <span class=hljs-comment >/* Logical Operation, result: 0 (false) */</span></code></pre>
<p>and since <strong>a</strong> is smaller than <strong>d</strong>, the value in the bracket is false, if we NOT this value we get a true. </p>
<pre><code class="cpp hljs"><span class=hljs-keyword >bool</span> r7 = !(a &gt;= b); <span class=hljs-comment >/* Logical Operation, result: 1 (true) */</span></code></pre>
<h1 id=float_vs_integer_math ><a href="#float_vs_integer_math" class=header-anchor >Float vs Integer Math</a></h1>
<p>
<center><iframe title=vimeo-player  src="https://player.vimeo.com/video/386922884" width=640  height=370  frameborder=0  allowfullscreen></iframe></center>
<br>
 There are a few important points to discuss regarding integer versus floating point math. </p>
<p>Remember that if you are performing arithmetic operations on integers, any decimal fraction resulting from the operation will be discarded. Should you just save the result into a float variable? Well, close but that’s not the complete picture. </p>
<p>Let’s see how that works. <pre><code class="cpp hljs"><span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;cstdint&gt;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;iostream&gt;</span></span>

<span class=hljs-keyword >using</span> <span class=hljs-keyword >namespace</span> std; 

<span class=hljs-function ><span class=hljs-keyword >int</span> <span class=hljs-title >main</span><span class=hljs-params >(<span class=hljs-keyword >int</span> argc, <span class=hljs-keyword >char</span>* argv[])</span> </span>{ 

    <span class=hljs-keyword >uint8_t</span> a = <span class=hljs-number >3</span>;
    <span class=hljs-keyword >uint8_t</span> b = <span class=hljs-number >4</span>; 
    <span class=hljs-keyword >float</span> bf = <span class=hljs-number >4.0</span>;
    <span class=hljs-keyword >uint16_t</span> c = b / a;  <span class=hljs-comment >/* integer divide operaton, result: 1 */</span>
    <span class=hljs-keyword >uint16_t</span> d = a / b;  <span class=hljs-comment >/* integer divide operaton, result: 0 */</span>
    <span class=hljs-keyword >uint16_t</span> e = a / bf; <span class=hljs-comment >/* float divide operaton,   result: 0, since e is an int */</span>
    <span class=hljs-keyword >float</span>    f = a / bf; <span class=hljs-comment >/* float divide operation,  result: 0.75 */</span>
    <span class=hljs-keyword >float</span>    g = a / b;  <span class=hljs-comment >/* integer divide operation, result: 0, even if g is float */</span>
    cout &lt;&lt; g &lt;&lt; endl;
    <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>; 
}</code></pre> Output: <pre><code class="plaintext hljs">0
</code></pre></p>
<p>Both d and a are integers, the division operation is done in integer math, the result is not 1.3 but 1, before the result is saved to the variable c</p>
<pre><code class="cpp hljs"><span class=hljs-keyword >uint16_t</span> c = b / a;  <span class=hljs-comment >/* integer divide operaton, result: 1 */</span></code></pre>
<p>The same applies here, a / b is 0.75 but this is integer math so the answer is 0.</p>
<pre><code class="cpp hljs"><span class=hljs-keyword >uint16_t</span> d = a / b;  <span class=hljs-comment >/* integer divide operaton, result: 0 */</span></code></pre>
<p>Here we divide the integer a by the float bf, this makes the math carried in float terms so the result is 0.75, but because it is saved into an integer the fraction is dropped and the value stored in e is 0</p>
<pre><code class="cpp hljs"><span class=hljs-keyword >uint16_t</span> e = a / bf; <span class=hljs-comment >/* float divide operaton,   result: 0, since e is an int */</span></code></pre>
<p>The math here is floating point math and now that the value to which the result is stored into is a float, then f would indeed store 0.75. </p>
<pre><code class="cpp hljs"><span class=hljs-keyword >float</span> f = a / bf; <span class=hljs-comment >/* float divide operation,  result: 0.75 */</span></code></pre>
<p>Here, even though the result variable is a float, again the mathematical operation was carried using integer math, because the values involved in the math operation are all integers.</p>
<pre><code class="cpp hljs"><span class=hljs-keyword >float</span>    g = a / b;  <span class=hljs-comment >/* integer divide operation, result: 0, even if g is float */</span></code></pre>
<h3 id=float_operation_but_int_variable ><a href="#float_operation_but_int_variable" class=header-anchor >Float operation but int variable</a></h3>
<p>Instead of using a float data type, if it is only required that a float operation be a subpart of a division, then, either the order of the operation would have to be adjusted such that multiplication occurs before division, such as with variable <strong>b</strong> below.</p>
<p><pre><code class="cpp hljs"><span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;cstdint&gt;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;iostream&gt;</span></span>

<span class=hljs-keyword >using</span> <span class=hljs-keyword >namespace</span> std; 

<span class=hljs-function ><span class=hljs-keyword >int</span> <span class=hljs-title >main</span><span class=hljs-params >(<span class=hljs-keyword >int</span> argc, <span class=hljs-keyword >char</span>* argv[])</span> </span>{ 

    <span class=hljs-keyword >uint8_t</span> a = (<span class=hljs-number >3</span> / <span class=hljs-number >4</span>) * <span class=hljs-number >4</span> ;      <span class=hljs-comment >/* stored result: 0 */</span>
    <span class=hljs-keyword >uint8_t</span> b = (<span class=hljs-number >3</span> * <span class=hljs-number >4</span>) / <span class=hljs-number >4</span> ;      <span class=hljs-comment >/* stored result: 3 */</span>
    <span class=hljs-keyword >uint8_t</span> c = (<span class=hljs-number >3</span>/(<span class=hljs-keyword >float</span>)<span class=hljs-number >4</span>) * <span class=hljs-number >4</span> ; <span class=hljs-comment >/* stored result: 3 */</span>
    cout &lt;&lt; (<span class=hljs-keyword >int</span>)c &lt;&lt; endl;
    <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>; 
}</code></pre> <pre><code class="plaintext hljs">3
</code></pre></p>
<p>Or the variable can be temporarily casted to a float in place here &#40;float&#41;</p>
<pre><code class="cpp hljs"><span class=hljs-keyword >uint8_t</span> c = (<span class=hljs-number >3</span>/(<span class=hljs-keyword >float</span>)<span class=hljs-number >4</span>) * <span class=hljs-number >4</span> ; <span class=hljs-comment >/* stored result: 3 */</span></code></pre>
<p>Both would allow for the result to be calculated.  </p>
<h3 id=type-casting_floats ><a href="#type-casting_floats" class=header-anchor >Type-Casting floats</a></h3>
<p>If one of the numbers in an arithmetic operation is expressed as a float, like the 240.0 here. Then this is an implicit way to ensure the arithmetic operation is performed in float terms.</p>
<p>Alternatively, a variable can be casted in-place to be a float, this basically creates a new temporary value that is a float. It does not change the variable itself to a float. </p>
<p><pre><code class="cpp hljs"><span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;cstdint&gt;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;iostream&gt;</span></span>

<span class=hljs-keyword >using</span> <span class=hljs-keyword >namespace</span> std; 
<span class=hljs-function ><span class=hljs-keyword >int</span> <span class=hljs-title >main</span><span class=hljs-params >(<span class=hljs-keyword >int</span> argc, <span class=hljs-keyword >char</span>* argv[])</span> </span>{ 

    <span class=hljs-keyword >uint8_t</span> input_voltage = <span class=hljs-number >130</span>;
    <span class=hljs-keyword >uint8_t</span> output_speed;

    <span class=hljs-comment >/* Output Speed = (Input Voltage) / 240 * 9 */</span>
    output_speed = input_voltage / <span class=hljs-number >240.0</span> * <span class=hljs-number >9</span>; <span class=hljs-comment >/* Dividing by a float implicitly */</span>
    output_speed = (<span class=hljs-keyword >float</span>)input_voltage / <span class=hljs-number >240</span> * <span class=hljs-number >9</span>; <span class=hljs-comment >/* Casting to a float, then dividing by an int */</span>

    cout &lt;&lt; (<span class=hljs-keyword >uint16_t</span>)output_speed &lt;&lt; endl;
    <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>; 
}</code></pre> Output: <pre><code class="plaintext hljs">4
</code></pre></p>
<p>We can cast variables from one type to another. Again, this doesn’t change the variable type itself, but creates a new temporary variable of a different type in place of the cast&#43;variable operation.</p>
<p>Even if you know the new variable can accept the value coming from an older but different data type variable, it is good practice to explicitly type cast to show intent and awareness that the type of the data has changed. </p>
<p>When performing floating point math, it is often desired to temporarily cast an int to a float to retain fractional values.</p>
<p>Assigning values between nonmatching datatypes can result in hard to track bugs, and worse, engineering disasters. </p>
<p>Next: <a href="../lesson8/">Control Structures</a></p>
<div class=page-foot >
  <div class=copyright >
    &copy; Ali AlSaibie, PhD. Last modified: April 02, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
    </div>  
    
    
        
<script src="/embedded_ccpp/libs/highlight/highlightjs-line-numbers.js"></script>